include: 'common.snakemake'

import shutil

data_dir=config.get('data_dir')
output_dir=config.get('output_dir')

rule all:
    input:
        expand('{output_dir}/fastq_gzip/{sample_id}_{mate_index}.fastq.gz',output_dir=output_dir,sample_id=sample_ids,mate_index=[1, 2]),
        expand('{output_dir}/trim/{sample_id}/{sample_id}.{mate_index}.clean.fq.gz',output_dir=output_dir,sample_id=sample_ids,mate_index=[1, 2]),
        expand('{output_dir}/filter/{sample_id}/{sample_id}.{mate_index}.filter.fq.gz',output_dir=output_dir,sample_id=sample_ids,mate_index=[1, 2]),
        expand('{output_dir}/sorted_bam/{sample_id}.{mate_index}.sorted.bam',output_dir=output_dir,sample_id=sample_ids,mate_index=[1, 2]),

rule fastq_gzip:
    input:
        fastq=config.get('data_dir') + '/fastq/{sample_id}_{mate_index}.fastq'
    output:
        fastq_gz='{output_dir}/fastq_gzip/{sample_id}_{mate_index}.fastq.gz'
    params:
        fastq_gz=config.get('data_dir') + '/fastq/{sample_id}_{mate_index}.fastq.gz',
        target_dir='{output_dir}/fastq_gzip'
    threads:
        config.get('threads_mapping')
    conda:
        'envs/mcta.yaml'
    log:
        '{output_dir}/log/fastq_gzip/{sample_id}_{mate_index}.log'
    shell:
        '''
            pigz -p {threads} {input.fastq} -k > {log} 2>&1 && mv {params.fastq_gz} {params.target_dir}
        ''' 


rule trim_fastq:
    input:
        fastq_gz1='{output_dir}/fastq_gzip/{sample_id}_1.fastq.gz',
        fastq_gz2='{output_dir}/fastq_gzip/{sample_id}_2.fastq.gz'
    output:
        trim1_fastq_1='{output_dir}/trim/{sample_id}/{sample_id}.1.clean.fq.gz',
        trim1_fastq_2='{output_dir}/trim/{sample_id}/{sample_id}.2.clean.fq.gz'
    params:
        trim_fastq_pl=config.get('root_dir') + '/bin/dna_meth/MCTA/trim_fastq.pl',
        indir='{output_dir}/fastq_gzip/',
        outdir='{output_dir}/trim/',
        sample_name='{sample_id}'
    threads:
        config.get('threads_mapping')
    conda:
        'envs/mcta.yaml'
    log:
        '{output_dir}/log/trim/{sample_id}.log'
    shell:
        '''
            perl {params.trim_fastq_pl} --indir {params.indir} --outdir {params.outdir} --sample {params.sample_name} > {log} 2>&1
        '''

rule filter_fastq:
    input:
        trim1_fastq_1='{output_dir}/trim/{sample_id}/{sample_id}.1.clean.fq.gz',
        trim1_fastq_2='{output_dir}/trim/{sample_id}/{sample_id}.2.clean.fq.gz'
    output:
        filter1_fastq_1='{output_dir}/filter/{sample_id}/{sample_id}.1.filter.fq.gz',
        filter1_fastq_2='{output_dir}/filter/{sample_id}/{sample_id}.2.filter.fq.gz'
    params:
        filter_fastq_pl=config.get('root_dir') + '/bin/dna_meth/MCTA/remove_forward6bp.pl',
    threads:
        config.get('threads_mapping')
    conda:
        'envs/mcta.yaml'
    log:
        fastq1_log='{output_dir}/log/filter/{sample_id}_1.log',
        fastq2_log='{output_dir}/log/filter/{sample_id}_2.log'
    shell:
        '''
            perl {params.filter_fastq_pl} {input.trim1_fastq_1} {output.filter1_fastq_1} 12 20 6 > {log.fastq1_log} 2>&1; \
            perl {params.filter_fastq_pl} {input.trim1_fastq_2} {output.filter1_fastq_2} 6 20 12 > {log.fastq2_log} 2>&1
        '''

rule bismark_mapping:
    input:
        filter_fastq_1='{output_dir}/filter/{sample_id}/{sample_id}.1.filter.fq.gz',
        filter_fastq_2='{output_dir}/filter/{sample_id}/{sample_id}.2.filter.fq.gz'
    output:
        bam_file1='{output_dir}/bismark_bam/{sample_id}_1/{sample_id}.1.filter_bismark.bam',
        bam_file2='{output_dir}/bismark_bam/{sample_id}_2/{sample_id}.2.filter_bismark.bam'
    params:
        genome=config.get('genome_dir'),
        bowtie1_bin_dir=config.get('bowtie1_bin_dir'),
        tmp_dir=config.get('temp_dir'),
        bam1_dir='{output_dir}/bismark_bam/{sample_id}_1',
        bam2_dir='{output_dir}/bismark_bam/{sample_id}_2',
        bam_file='{output_dir}/bismark_bam/{sample_id}_trim_1_bismark_bt2_pe.bam'
    threads:
        8    ## using more than 4 cores per alignment thread has been reported to have diminishing returns. If possible try to limit -p to a value of 4
    conda:
        "envs/mcta.yaml"
    log:
        fastq1_log='{output_dir}/log/bismark_bam/{sample_id}_1.log',
        fastq2_log='{output_dir}/log/bismark_bam/{sample_id}_2.log'
    shell:
        '''
            bismark --bowtie1 --non_directional --fastq --phred33-quals --temp_dir {params.tmp_dir} \
                    --path_to_bowtie {params.bowtie1_bin_dir} --output_dir {params.bam1_dir} {params.genome} \
                    {input.filter_fastq_1} > {log.fastq1_log} 2>&1 ; \
            bismark --bowtie1 --non_directional --fastq --phred33-quals --temp_dir {params.tmp_dir} \
                    --path_to_bowtie {params.bowtie1_bin_dir} --output_dir {params.bam2_dir} {params.genome} \
                    {input.filter_fastq_2} > {log.fastq2_log} 2>&1 ;

        '''

rule bam_sorted:
    input:
        bam_file1='{output_dir}/bismark_bam/{sample_id}_1/{sample_id}.1.filter_bismark.bam',
        bam_file2='{output_dir}/bismark_bam/{sample_id}_2/{sample_id}.2.filter_bismark.bam'
    output:
        sorted1='{output_dir}/sorted_bam/{sample_id}.1.sorted.bam',
        sorted2='{output_dir}/sorted_bam/{sample_id}.2.sorted.bam'
    threads:
        config.get('threads_mapping')
    conda:
        'envs/mcta.yaml'
    log:
        log1='{output_dir}/log/bam_sorted/{sample_id}_1.log',
        log2='{output_dir}/log/bam_sorted/{sample_id}_2.log'
    shell:
        '''
            samtools sort -@ {threads} {input.bam_file1} -o {output.sorted1} > {log.log1} 2>&1; \
            samtools sort -@ {threads} {input.bam_file2} -o {output.sorted2} > {log.log2} 2>&1 ; \
            samtools index {output.sorted1} ; \
            samtools index {output.sorted2}
        '''

# rule bismark_methylation_extract:
#     input:
#         sorted1='{output_dir}/sorted_bam/{sample_id}.1.sorted.bam',
#         sorted2='{output_dir}/sorted_bam/{sample_id}.2.sorted.bam'
#     output:
#         coverage_dir=directory('{output_dir}/bismark_methylation_extract')
#     threads:
#         config.get('threads_mapping')
#     conda:
#         'envs/mcta.yaml'
#     log:
#         '{output_dir}/log//.log'
#     shell:
#         '''
#             bismark_methylation_extractor -s {input.sorted1} {input.sorted2} --bedGraph --counts -o {this_sample_out} > {this_log_dir} 2>&1
#         '''

# rule merge_cpg_pos:
#     input:
#         coverage_dir='{output_dir}/bismark_methylation_extract'
#     output:

#     params:
#         genome=config.get('genome_dir')
#     threads:
#         config.get('threads_mapping')
#     conda:
#         'envs/mcta.yaml'
#     log:
#         '{output_dir}/log//.log'
#     shell:
#         '''
#             python3 merge_cpg_pos.py -i {input.coverage_dir} -p {threads} -f {params.genome}/CpGs/hg38_cpgs.txt.gz
#         '''

# rule merge_two_coverage:
#     input:
#         coverage_dir='{output_dir}/bismark_methylation_extract'
#     output:
#         merged_dir='{output_dir}/merge_two_coverage/{sample_id}'
#     params:
#         merge_two_coverage_script=config.get('root_dir') + '/bin/dna_meth/MCTA/merge_two_coverage.py',

#     threads:
#         config.get('threads_mapping')
#     conda:
#         'envs/mcta.yaml'
#     log:
#         '{output_dir}/log//.log'
#     shell:
#         '''
#             python {params.merge_two_coverage_script} -i [merged CpG coverage dir] -o {output.merged_dir}
#         '''

# rule get_wiggle_file:
#     input:

#     output:

#     params:
#         coverage_script=config.get('root_dir') + '/bin/dna_meth/WGBS_RRBS/coverage_to_wig.py'
#     wildcard_constraints:

#     threads:
#         config.get('threads_mapping')
#     conda:
#         'envs/mcta.yaml'
#     log:
#         '{output_dir}/log//.log'
#     shell:
#         '''
#             python {params.coverage_script} {params.coverage_dir} > {log.get_wiggle_log} 2>&1
#         '''